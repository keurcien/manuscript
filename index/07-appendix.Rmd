`r if(knitr:::is_latex_output()) '\\appendix'`

`r if(!knitr:::is_latex_output()) '# (APPENDIX) Appendice {-}'` 

# Détails

### Rapport entre la communalité et l'indice de fixation

Pour établir le lien entre la $F_{ST}$ et la communalité, nous nous plaçons dans le cas de deux populations $A$ et $B$, composées respectivement de $n_1$ et $n_2$ individus. Nous rappelons que la communalité correspond à la somme quadratique des loadings pondérés par la variance des composantes principales. Notons $n = n_1 + n_2$, $\boldsymbol{G}$ la matrice de génotypes et $G$ le vecteur de taille $n$ contenant le génotype des individus pour un allèle donné (G correspond à une ligne de $\boldsymbol{G}$). En reprenant la définition \@ref(def:fst) de la $F_{ST}$ dans le cas $N = 2$, les fréquences alléliques $p_i$ s'écrivent $p_1 = \sum_{i=1}^n \delta_{1i} G_{i} / \sum_{i=1}^n \delta_{1i}$ et  $p_2 = \sum_{i=1}^n \delta_{2i} G_{i} / \sum_{i=1}^n \delta_{2i}$ où $\delta_{ki} = 1$ si l'individu $i$ appartient à la population $k$ et $0$ sinon. Commençons par exprimer la $F_{ST}$ en fonction des génotypes :

\begin{equation}
  \begin{split}
  F_{ST} & = \frac{1}{2-1}\frac{\sum_{i=1}^2 (p_i - \bar{p})^2}{\bar{p}(1-\bar{p})} \\
  & = \frac{1}{\bar{p}(1-\bar{p})} \left(\left(\frac{\sum_{i=1}^n \delta_{1i} G_{i}}{\sum_{i=1}^n \delta_{1i}} - \bar{p}\right)^2 + \left(\frac{\sum_{i=1}^n \delta_{2i} G_{i}}{\sum_{i=1}^n \delta_{2i}} - \bar{p}\right)^2\right)\\
  & = \frac{1}{\bar{p}(1-\bar{p})} \left(\left(\frac{\sum_{i=1}^n \delta_{1i} (G_{i} - \bar{p})}{n_1}\right)^2 + \left(\frac{\sum_{i=1}^n \delta_{2i} (G_{i} - \bar{p})}{n_2}\right)^2\right)\\
  \end{split}
  (\#eq:fst-communality-proof)
\end{equation}

Notant $\tilde{G}_i = \frac{G_i - \bar{p}}{\sqrt{\bar{p}(1-\bar{p})}}$ :

\begin{equation}
  F_{ST} = \left(\sum_{i=1}^n \frac{\delta_{1i}}{n_1} \tilde{G_{i}}\right)^2 + \left(\sum_{i=1}^n \frac{\delta_{2i}}{n_2} \tilde{G_{i}}\right)^2\\
  (\#eq:fst-communality-proof-2)
\end{equation}

ce qui peut se réécrire $F_{ST} = ||\tilde{G}^T U_{\delta}||_2^2$ où $U_{\delta}  = (\frac{\delta_{ji}}{n_j})_{1 \leq i \leq n, \; 1\leq j \leq 2} \in M_{n, 2}(\mathbb{R})$. Si le premier et le quatrième individu appartiennent à la population $A$ et que le deuxième et le troisième individu appartiennent à la population $B$, la matrice $U_{\delta}$ s'écrit :

$$U_{\delta} = \begin{pmatrix}\frac{1}{n_1} & 0\\
0 & \frac{1}{n_2}\\
0 & \frac{1}{n_2}\\
\frac{1}{n_1} & 0
\end{pmatrix}$$

Pour faire le parallèle avec la communalité, il est nécessaire de trouver une matrice colonne $U_{\delta}^{\prime} \in M_{n, 1}(\mathbb{R})$ telle que $F_{ST} = ||\tilde{G}^T U_{\delta}^{\prime}||_2^2$. Pour ce faire, nous allons chercher une matrice de rotation telle que $U_{\delta}R$ ait sa première colonne constante, c'est-à-dire telle que :

\begin{equation}
  \begin{pmatrix}\frac{1}{n_1} & 0\\
    0 & \frac{1}{n_2}
  \end{pmatrix}R =
  \begin{pmatrix} a & x\\
    a & y
  \end{pmatrix}
  (\#eq:condition-1)
\end{equation}

où $x, y, a$ sont des réels à déterminer. Soit $R \in M_2(\mathbb{R})$ une matrice de rotation :

$$R = \begin{pmatrix}\cos\theta & -\sin\theta\\
\sin\theta & \cos\theta
\end{pmatrix}$$

En injectant $R$ dans \@ref(eq:condition-1), on obtient :

\begin{equation}
  \begin{pmatrix}\frac{\cos\theta}{n_1} & -\frac{\sin\theta}{n_1}\\
    \frac{\sin\theta}{n_2} & \frac{\cos\theta}{n_2}
  \end{pmatrix} =
  \begin{pmatrix} a & x\\
    a & y
  \end{pmatrix}
  (\#eq:condition-2)
\end{equation}

\@ref(eq:condition-2) implique que l'angle de la rotation vérifie la relation $\frac{\cos\theta}{n_1} = \frac{\sin\theta}{n_2}$, qui a pour solution dans $]-\frac{\pi}{2}, \frac{\pi}{2}[$, $\theta = \arctan(\frac{n_2}{n_1})$. Nous en déduisons ainsi les valeurs de $x$ et de $y$ :

\begin{equation}
  \begin{split}
  x & = -\frac{\sin(\arctan(\frac{n_2}{n_1}))}{n_1} \\
  y & = \frac{\cos(\arctan(\frac{n_2}{n_1}))}{n_2} \\
  \end{split}
  (\#eq:xy)
\end{equation}

Or :

\begin{equation}
  \begin{split}
  \sin(\arctan(x)) & = \frac{x}{\sqrt{1 + x^2}} \\
  \cos(\arctan(x)) & = \frac{1}{\sqrt{1 + x^2}}
  \end{split}
  (\#eq:trigo)
\end{equation}

Notant $R$ la rotation d'angle $\arctan(\frac{n_2}{n_1})$, on a finalament :

$$U_{\delta}R = \begin{pmatrix}a & -\delta_{11}  \frac{n_2}{\sqrt{n_1^2+n_2^2}} + \delta_{21} \frac{n_1}{\sqrt{n_1^2+n_2^2}}\\
a & -\delta_{12}  \frac{n_2}{\sqrt{n_1^2+n_2^2}} + \delta_{22} \frac{n_1}{\sqrt{n_1^2+n_2^2}}\\
\vdots & \vdots \\
a & -\delta_{1n}  \frac{n_2}{\sqrt{n_1^2+n_2^2}} + \delta_{2n} \frac{n_1}{\sqrt{n_1^2+n_2^2}}
\end{pmatrix}$$

Puisque $R$ est une rotation, $||\tilde{G}^T U_{\delta}||_2 = ||\tilde{G}^T U_{\delta}R||_2$. En développant $\tilde{G}^T U_{\delta}R$, on obtient :

\begin{equation}
  \begin{split}
   \tilde{G}^T U_{\delta}R = \left(\sum_{i=1}^n a \tilde{G}_i, \sum_{i=1}^n \left(-\delta_{1i}  \frac{n_2}{\sqrt{n_1^2+n_2^2}} + \delta_{2i} \frac{n_1}{\sqrt{n_1^2+n_2^2}}\right)\tilde{G}_i \right)
  \end{split}
\end{equation}

Or $\sum_{i=1}^n \tilde{G}_i = 0$ par définition de $\tilde{G}$, ce qui permet d'écrire, en posant $U_{\delta}^{\prime} \in M_{n,1}(\mathbb{R})$ la matrice colonne correspondant à la deuxième colonne de $U_{\delta}R$ :

\begin{equation}
  \begin{split}
    F_{ST} & = ||\tilde{G}^T U_{\delta}||_2^2 \\
    & = ||\tilde{G}^T U_{\delta}R||_2^2 \\
    & = ||\tilde{G}^T U_{\delta}^{\prime}||_2^2
  \end{split}
\end{equation}

```{r}
n1 <- 1/5
n2 <- 1/8
xx <- c(-1/4, 1/4)
xx.2 <- c(-0.15, 0.15)
yy.1 <- - n2 * xx / n1
yy.2 <- n1 * xx.2 / n2
n.x <- c(n1, 0)
n.y <- c(0, n2)
df.branch <- data.frame(x1 = n.x[1], x2 = n.x[2], y1 = n.y[1], y2 = n.y[2])
df.axis.x <- data.frame(x1 = xx[1], x2 = xx[2], y1 = yy.1[1], y2 = yy.1[2])
df.axis.y <- data.frame(x1 = xx.2[1], x2 = xx.2[2], y1 = yy.2[1], y2 = yy.2[2])
data.frame(x = n.x, y = n.y) %>%
  ggplot(aes(x = x, y = y)) +
  coord_equal() +
  geom_point(size = 2, color = "red") +
  xlim(-1/4, 1/4) +
  ylim(-1/4, 1/4) +
  xlab("X") +
  ylab("Y") +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_segment(data = df.branch, aes(x = x1, y = y1, xend = x2, yend = y2)) +
  geom_segment(data = df.axis.x, aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue") +
  geom_segment(data = df.axis.y, aes(x = x1, y = y1, xend = x2, yend = y2), color = "blue") +
  annotate("text",
           x = n.x + c(0, 0.01),
           y = n.y + c(0.025, 0),
           label = c("frac(1, n[1])", "frac(1, n[2])"),
           parse = TRUE) +
  theme_bw()

```

Notant $\tilde{\boldsymbol{G}} = U \Sigma V^T$ la SVD de rang 1, la communalité a pour expression $\rho_1^2 = (\Sigma V)^2 = ||\tilde{G}^TU||_2^2$.
Remarquons que $U_{\delta}^{\prime}$ a une expression similaire à celle des scores de l'ACP exprimée dans @mcvean2009genealogical. Ceci nous permet de considérer la $F_{ST}$ comme un cas particulier de la communalité où les scores de l'ACP sont identiques pour tous les individus appartenant à une même population. À l'inverse, cela permet de voir la communalité comme une extension de la $F_{ST}$ à l'échelle individuelle.


### L'Analyse en Composantes Principales régularisée

L'Analyse en Composantes Principales parcimonieuse est utilisée pour donner une meilleure interprétabilité des composantes principales. Les composantes principales classiques sont des combinaisons linéaires de toutes les variables de départ, si bien que n'importe quelle composante principale renvoie potentiellement à toutes les variables du jeu de données. L'Analyse en Composantes Principales permet de contourner ce problème en ne sélectionnant qu'un certain nombre de variables pour construire ses composantes principales, attribuant des valeurs nulles aux autres variables.

```{r, eval=FALSE}
create.fdr.pow = function(list, ground.truth, lmax = length(list), smooth = TRUE, soft.name){
  fdr <- 0
  pow <- 0
  s <- seq(1, lmax, by = 1)
  for (k in s){
    l <- list[1:k]
    fdr <- c(fdr, simulate::compute.fdr(l, ground.truth))
    pow <- c(pow, simulate::compute.power(l, ground.truth))
  }
  res <- list()
  idx <- sort(fdr, decreasing = FALSE, index.return = TRUE)$ix
  fdr <- fdr[idx]
  pow <- pow[idx]
  if (smooth == FALSE){
    res$fdr <- fdr
    res$pow <- pow
  } else if (smooth == TRUE){
    pow.old <- 0
    fdr.old <- 0
    aux.fdr <- 0
    aux.pow <- 0
    for (val in 1:length(fdr)){
      if (pow[val] >= pow.old){
        aux.fdr <- c(aux.fdr, fdr[val])
        aux.pow <- c(aux.pow, pow[val])
        pow.old <- pow[val]
      }
    }
    res$fdr <- aux.fdr
    res$pow <- aux.pow
  }
  return(data.frame(Software = soft.name, 
                    FDR = fdr,
                    Power = pow))
}

#d <- readRDS("data/div.rds")

dir <- "~/Documents/thesis/git/simulations/divergence_model/"
n.simu <- c(25, 50, 75, 100, 150, 175)

pow <- 0
fdr <- 0
pow.pcadapt <- 0
fdr.pcadapt <- 0
for (i in 1:length(n.simu)) {
  geno <- t(as.matrix(read.table(paste0(dir, "div3pops_Eur_", n.simu[i]))))
  gt <- scan(paste0(dir, "div3pops_Eur_", n.simu[i], ".gt"))
  x <- pcadapt(geno, K = 2)
  p <- apply(geno, MARGIN = 1, FUN = function(X) {mean(X) / 2})
  G <- scale(t(geno), center = TRUE, scale = sqrt(2 * p * (1 - p)))
  obj.spca <- elasticnet::spca(G, K = 2, para = c(0.1, 0.1))
  h2 <- obj.spca$pev[1] * obj.spca$loadings[, 1]^2 + obj.spca$pev[2] * obj.spca$loadings[, 2]^2

  rnk <- sort(h2, decreasing = TRUE, index.return = TRUE)$ix
  rnk.pcadapt <- sort(x$pvalues, decreasing = FALSE, index.return = TRUE)$ix
  pow <- pow + sapply(1:1000, FUN = function(h) {simulate::compute.power(rnk[1:h], gt)})
  fdr <- fdr + sapply(1:1000, FUN = function(h) {simulate::compute.fdr(rnk[1:h], gt)})
  pow.pcadapt <- pow.pcadapt + sapply(1:1000, FUN = function(h) {simulate::compute.power(rnk.pcadapt[1:h], gt)})
  fdr.pcadapt <- fdr.pcadapt + sapply(1:1000, FUN = function(h) {simulate::compute.fdr(rnk.pcadapt[1:h], gt)})
}
plot(fdr / length(n.simu), pow / length(n.simu))
points(fdr.pcadapt / length(n.simu), pow.pcadapt / length(n.simu), col = "red")
```

# Informations supplémentaires

## Article 1 {-}

## Article 2 {-}

(ref:FigureSI1-cap) Schematic description of the island and divergence model. For the island model, adaptation occurs simultaneously in each population. For the island model, adaptation takes place in the branch leading to the second population.

```{r FigureSI1, results='asis', fig.cap='(ref:FigureSI1-cap)'}
include_graphics("figure/FigureSI1.png")
```

(ref:FigureSI2-cap) Proportion of false discoveries and statistical power as a function of the number of principal components in a model of range expansion.

```{r FigureSI2, fig.height=4, fig.cap='(ref:FigureSI2-cap)'}
dt <- readRDS("data/rexp.rds")
p <- ncol(data)
K <- 4:9
df <- data.frame(values = vector(mode = "numeric",
                                 length = 2 * length(K)),
                 type = c(rep("FDR", length(K)),
                          rep("Power", length(K))),
                 K = rep(K, 2))

for (k in 1:length(K)) {
  x <- pcadapt(dt$geno,
               K = K[k],
               ploidy = 1,
               min.maf = 0)
  qval <- qvalue(x$pvalues)$qvalues
  rnk <- which(qval < 0.1)

  if (length(rnk) > 0) {
    df$values[df$type == "FDR"][k] <- sum(!(rnk %in% dt$ground.truth)) / length(rnk)
  }
  df$values[df$type == "Power"][k] <- sum(rnk %in% dt$ground.truth)/length(dt$ground.truth)
}

ggplot(data = df) +
  geom_line(size = 2,
            aes(x = K,
                y = values,
                colour = type)) +
  ylim(0,1) +
  scale_colour_manual("Curve",
                      values = cbbPalette[c(7, 3)]) +
  guides(colour = guide_legend(nrow = 1)) +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        axis.title.y = element_blank(),
        legend.title.align = 0.5,
        legend.key.width = unit(5, "line"))
```

(ref:FigureSI3-cap) Statistical power averaged over the expected proportion of false discoveries
(ranging between 0% and 50%) for the island model.

```{r FigureSI3, fig.height=4, fig.cap='(ref:FigureSI3-cap)'}
readRDS("data/isldivrexp.rds") %>%
  filter(model == "isl") %>%
  ggplot(aes(x = software,
             y = measure,
             fill = factor(type))) +
  geom_bar(stat = "identity",
           position = "dodge",
           color = "black") +
  ylim(0, 1) +
  scale_fill_manual(values = c("lightblue", "darkblue"),
                    labels = c("No admixture", "With admixture")) +
  scale_x_discrete(labels = c("BayeScan",
                              "hapflk",
                              "OutFLANK",
                              "pcadapt",
                              "sNMF")) +
  xlab("Software") +
  ylab("Power") +
  theme_bw() +
  theme(axis.text.x = element_text(face = "italic"),
        legend.title = element_blank(),
        legend.position = c(0.125, 0.9),
        legend.background = element_rect(fill = alpha("white", 0)))
```

\newpage

(ref:FigureSI4-cap) Statistical power as a function of the proportion of false discoveries for the island model.

```{r FigureSI4, fig.height=9, fig.cap='(ref:FigureSI4-cap)'}
df <- readRDS("data/curves-fdrpower.rds") %>%
  filter(model %in% c("isl", "islh")) %>%
  droplevels()
levels(df$model) <- c("No admixture", "With admixture")
df %>%
  ggplot(aes(x = fdr,
             y = power)) +
  facet_wrap(~model, ncol = 1) +
  geom_line(aes(color = software), size = 1.5, na.rm = TRUE) +
  scale_color_manual("Software",
                     values = cbbPalette[c(7, 2, 4, 3, 8)],
                     labels = c("BayeScan",
                                "hapflk",
                                "OutFLANK",
                                "pcadapt",
                                "sNMF")) +
  xlim(0, 0.6) +
  ylim(0, 1) +
  guides(colour = guide_legend(nrow = 2),
         linetype = guide_legend(nrow = 2)) +
  xlab("FDR") +
  ylab("Power") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.title.align = 0.5,
        legend.text = element_text(face = "italic"),
        legend.key.width = unit(5, "line"))
```

\newpage

(ref:FigureSI5-cap) Statistical power as a function of the proportion of false discoveries for the divergence model.

```{r FigureSI5, fig.height=9, fig.cap='(ref:FigureSI5-cap)'}
df <- readRDS("data/curves-fdrpower.rds") %>%
  filter(model %in% c("div", "divh")) %>%
  droplevels()
levels(df$model) <- c("No admixture", "With admixture")
df %>%
  ggplot(aes(x = fdr,
             y = power)) +
  facet_wrap(~model, ncol = 1) +
  geom_line(aes(color = software), size = 1.5, na.rm = TRUE) +
  scale_color_manual("Software",
                     values = cbbPalette[c(7, 2, 4, 3, 8)],
                     labels = c("BayeScan",
                                "hapflk",
                                "OutFLANK",
                                "pcadapt",
                                "sNMF")) +
  xlim(0, 0.6) +
  ylim(0, 1) +
  guides(colour = guide_legend(nrow = 2),
         linetype = guide_legend(nrow = 2)) +
  xlab("FDR") +
  ylab("Power") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.title.align = 0.5,
        legend.text = element_text(face = "italic"),
        legend.key.width = unit(5, "line"))
```

\newpage

(ref:FigureSI6-cap) Statistical power as a function of the proportion of false discoveries for the
model of range expansion.

```{r FigureSI6, fig.height=5, fig.cap='(ref:FigureSI6-cap)'}
df <- readRDS("data/curves-fdrpower.rds") %>%
  filter(model == "rexp") %>%
  droplevels()
levels(df$model) <- c("No admixture", "With admixture")
df %>%
  ggplot(aes(x = fdr,
             y = power)) +
  geom_line(aes(color = software), size = 1.5, na.rm = TRUE) +
  scale_color_manual("Software",
                     values = cbbPalette[c(7, 2, 4, 3, 8)],
                     labels = c("BayeScan",
                                "hapflk",
                                "OutFLANK",
                                "pcadapt",
                                "sNMF")) +
  xlim(0, 0.6) +
  ylim(0, 1) +
  guides(colour = guide_legend(nrow = 2),
         linetype = guide_legend(nrow = 2)) +
  xlab("FDR") +
  ylab("Power") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.title.align = 0.5,
        legend.text = element_text(face = "italic"),
        legend.key.width = unit(5, "line"))
```

(ref:FigureSI7-cap) Running times of the different computer programs. The different programs were run on genotype matrices containing 300 individuals and from 500 to 50,000 SNPs. The characteristics of the computer we used to perform comparisons are the following: OSX El Capitan 10.11.3, 2,5 GHz Intel Core i5, 8 Go 1600 MHz DDR3.

```{r FigureSI7, fig.height=4, fig.cap='(ref:FigureSI7-cap)'}
readRDS("data/runtime-molecol.rds") %>%
  mutate(Runtime = log10(Runtime + 1)) %>%
  ggplot(aes(x = nSNP,
             y = Runtime,
             colour = Software)) +
  scale_y_continuous(breaks = 0:3, labels = c(0, 10, 100, 1000)) +
  scale_color_manual(values = cbbPalette[c(2, 4, 3, 8)]) +
  guides(colour = guide_legend(nrow = 1)) +
  geom_point(size = 5) +
  geom_line(size = 2) +
  ylab("Running time (seconds)") +
  xlab("Number of SNPs") +
  theme_bw() +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        legend.title.align = 0.5,
        legend.text = element_text(face = "italic"),
        legend.key.width = unit(5, "line"))
```

## Article 3 {-}

(ref:ancestry-cap) Standardized average ancestry coefficient computed with pcadapt and different LAI methods (EILA, Loter and  RFMix) for a population of simulated admixed individuals. Simulations use phased genotype data from $25$ *Populus balsamifera* individuals and $25$ *Populus trichocarpa* individuals and assume that admixture took place $\lambda=100$ generations ago. A total of $25$ admixed individuals were generated assuming $30\%$ of *Populus balsamifera* ancestry except from the 5 outlier $500$ SNP regions where *Populus balsamifera* ancestry is of $50\%$.

```{r ancestry, results='asis', fig.cap='(ref:ancestry-cap)'}
include_graphics("figure/ancestry.png")
```

(ref:losspower-admix-cap) Relative loss of power of the different methods when compared to an ideal method called *oracle*, which would know ancestry chunks for each admixed individual. The relative power is averaged over the difference $\Delta_q$ of ancestry between neutral and outlier regions. Simulations use phased genotype data from $25$ *Populus balsamifera* individuals and $25$ *Populus trichocarpa* individuals and assume that admixture took place $\lambda$ generations ago. A total of $25$ admixed individuals were generated assuming $70\%$ of *Populus balsamifera* ancestry except from the 5 outlier $500$ SNP regions where *Populus balsamifera* ancestry is of $70\%-\Delta_q$ where $\Delta_q$ is equal to $0.05$, $0.10$, $0.15$, $0.20$, $0.30$, $0.40$, or $0.50$.

```{r losspower-admix, results='asis', fig.cap='(ref:losspower-admix-cap)'}
include_graphics("figure/meanloss_admixture.png")
```

(ref:power-admix-max-cap) Proportion of true outlier peaks among the five top peaks found with pcadapt and different LAI methods (EILA, Loter and  RFMix) in a scenario where 2 Populus populations experienced admixture. Compared to Figure \@ref(fig:power-admix), we compute maximum of ancestry coefficients within each genomic region instead of mean of ancestry coefficients. Proportion of true outlier peaks are displayed as a function of the difference $\Delta_q$ of ancestry between outlier and neutral regions. The three panels correspond to the three different possible values ($\lambda=10$ or $100$ or $1000$) of the number of generations since admixture.

```{r power-admix-max, results='asis', fig.cap='(ref:power-admix-max-cap)'}
include_graphics("figure/power_Dq_max.png")
```

(ref:si-power-admix-cap) Proportion of true outlier peaks as a function of the number of top peaks found with pcadapt and different LAI methods (EILA, Loter and RFMix) in a scenario where 2 Populus populations experienced admixture. The different panels correspond to the different possible values for the number of generations since admixture occurred ($\lambda=\{10,100,1000\}$) and to the different values of the difference of ancestry $\Delta_q$ between neutral and outlier regions.

```{r si-power-admix, results='asis', fig.cap='(ref:si-power-admix-cap)'}
#include_graphics("figure/power_Dq_curves.png")
adm.df <- readRDS("data/admixture_power_top_hits.rds")
adm.df %>%
  ggplot(aes(x = NumberOfTopHits,
             y = Power,
             colour = Method)) +
  xlab("Number of top hits") +
  ylab("Power") +
  scale_color_manual(values = c("#000000", # Oracle
                                "white",
                                "white",
                                "#D55E00", # Loter
                                "#009E73", # RFMix
                                "white",
                                "white",
                                "#E69F00", # EILA
                                "#56B4E9"), # pcadapt
                     drop = FALSE) +
  geom_line(size = 1) +
  facet_grid(Dp ~ TimeSinceAdmixture) +
  scale_y_continuous(breaks = c(0.5, 1)) +
  scale_x_continuous(breaks = c(0, 25, 50)) +
  theme_bw(base_size = 20) + guides(colour = guide_legend(title = " ")) +
  theme(axis.text = element_text(face = "bold"),
        axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)),
        axis.title = element_text(face = "bold"),
        title = element_text(face = "bold"),
        strip.text = element_text(face = "bold"),
        legend.text = element_text(face = "bold"),
        legend.key.height = unit(3, "line"),
        legend.key.width = unit(3, "line"),
        panel.spacing = unit(0.5, "lines"))
```

(ref:GF-power-top-hits-cap) Power as a function of the number of top hits.

```{r GF-power-top-hits, fig.cap='(ref:GF-power-top-hits-cap)'}
gf.df <- readRDS("data/GF_power_top_hits.rds")
gf.df %>%
  filter(mutationRate == "Constant mutation rate", GF <= 0.5) %>%
  ggplot(aes(x = NumberOfTopHits,
             y = Power,
             colour = Method)) +
  xlab("Number of top hits") +
  ylab("Power") +
  geom_line(size = 1) +
  facet_grid(GF~tGF) +
  scale_color_manual(labels = c(expression(bold(Bd)[italic(f)]),
                                expression(bolditalic(D)),
                                expression(bolditalic(f[italic(d)])),
                                expression(bold(pcadapt)),
                                expression(bolditalic(RND)[min])),
                     values = c("#D55E00", # Bdf
                                "#E69F00", # D
                                "#009E73", # f
                                "#56B4E9", # pcadapt
                                "#CC79A7"), # RNDmin
                     drop = FALSE) +
  scale_y_continuous(breaks = c(0.5, 1)) +
  scale_x_continuous(breaks = c(0, 25, 50)) +
  theme_bw(base_size = 20) + guides(colour = guide_legend(title = " ")) +
  theme(axis.text = element_text(face = "bold"),
        axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)),
        axis.title = element_text(face = "bold"),
        title = element_text(face = "bold"),
        strip.text = element_text(face = "bold"),
        legend.text = element_text(face = "bold"),
        legend.key.height = unit(3, "line"),
        legend.text.align = 0,
        legend.key.width = unit(3, "line"),
        panel.spacing = unit(0.5, "lines"))
```

(ref:introgression-cap) Schematic description of simulations under an introgression scenario.

```{r introgression, results='asis', fig.cap='(ref:introgression-cap)'}
include_graphics("figure/introgression.png")
```

(ref:admixture-cap) Schematic description of simulations under an admixture scenario.

```{r admixture, results='asis', fig.cap='(ref:admixture-cap)'}
include_graphics("figure/admixture.png")
```

(ref:annotation-cap) Transcripts detected with pcadapt in chromosome 6 and not detected in [@suarez2016] located in regions with excess of *Populus balsamifera* ancestry.

```{r annotation, results='asis', message=FALSE}
name <- c("Potri.006G156000.1",
          "Potri.006G156100.1",
          "Potri.006G156200.1",
          "Potri.006G161800.1",
          "Potri.006G161900.1")

region <- c("14266001:14305734",
        "14266001:14305734",
        "14266001:14305734",
        "15556790:15791830",
        "15556790:15791830")

func <- c("Sulfate transporter",
        "Not named",
        "Not named",
        "Not named",
        "Vernalization intensive protein")

data.frame(name = name,
           region = region,
           func = func) %>%
  knitr::kable(col.names = c("Transcript",
                             "Region",
                             "PANTHER annotation"),
               caption = '(ref:annotation-cap)',
               booktabs = TRUE,
               escape = TRUE) %>%
  kable_styling(full_width = T)
```


# R & Python

## Simulations et modèles démographiques

Nous mettons ici à disposition une partie des codes qui ont servi à produire les simulations et à leur exploitation.

### Modèle en île

(ref:island-pca-cap) Exemple de simulation réalisée à l'aide de *ms* [@hudson2002generating].

```{r island-pca, fig.cap='(ref:island-pca-cap)', echo=TRUE}
if (!file.exists("ms/ms")) {
  system("gcc -o ms/ms ms/ms.c ms/streec.c ms/rand1.c -lm")
}

### ms : list of parameters ###
nb_demes <- 3
nCHR_per_POP <- 50
nCHR <- nb_demes * nCHR_per_POP
nIND <- nCHR / 2
nb_neutral <- 100
nb_adaptive <- 25
mig_rate_neutral <- 10
mig_rate_adaptive <- 0.1
###############################

nCHR_per_POP_string <- nCHR_per_POP
for (k in 1:(nb_demes - 1)) {
  nCHR_per_POP_string <- paste(nCHR_per_POP_string, nCHR_per_POP)
}

mig_rate_neutral_string <- "x"
mig_rate_adaptive_string <- "x"
for (k in 1:nb_demes){
  for (j in 1:nb_demes){
    if ((k == j) && (k > 1)){
      mig_rate_neutral_string <- paste(mig_rate_neutral_string, "x")
      mig_rate_adaptive_string <- paste(mig_rate_adaptive_string, "x")
    } else if (k != j) {
      mig_rate_neutral_string <- paste(mig_rate_neutral_string,
                                       mig_rate_neutral)
      mig_rate_adaptive_string <- paste(mig_rate_adaptive_string,
                                        mig_rate_adaptive)
    }
  }
}

cmd_neutral <- paste("ms/./ms",
                     nCHR,
                     nb_neutral,
                     "-s 1 -I",
                     nb_demes,
                     nCHR_per_POP_string,
                     "-ma",
                     mig_rate_neutral_string,
                     ">",
                     "data/neutral.txt")

cmd_adaptive <- paste("ms/./ms",
                      nCHR,
                      nb_adaptive,
                      "-s 1 -I",
                      nb_demes,
                      nCHR_per_POP_string,
                      "-ma",
                      mig_rate_adaptive_string,
                      ">",
                      "data/adaptive.txt")

system(cmd_neutral)
system(cmd_adaptive)

file.neutral <- scan(file = "data/neutral.txt",
              what = "character",
              sep = "\n",
              skip = 2)

g.neutral <- NULL

for (locus in 1:nb_neutral){
  res.locus1 <- file.neutral[4:(nCHR + 3)]
  file.neutral <- file.neutral[-(1:(nCHR+3))]
  g.neutral <- cbind(g.neutral, as.numeric(as.factor(res.locus1)))
}

file.adaptive <- scan(file = "data/adaptive.txt",
                      what = "character",
                      sep = "\n",
                      skip = 2)

g.adaptive <- NULL

for (locus in 1:nb_adaptive){
  res.locus1 <- file.adaptive[4:(nCHR + 3)]
  file.adaptive <- file.adaptive[-(1:(nCHR+3))]
  g.adaptive <- cbind(g.adaptive, as.numeric(as.factor(res.locus1)))
}

g <- cbind(g.neutral, g.adaptive)

x <- pcadapt::pcadapt(t(g), K = 2)
pop <- c(rep("A", 50), rep("B", 50), rep("C", 50))
plot(x, option = "scores", pop = pop)
```

(ref:island-manhattan-cap) Manhattan plot obtenu à partir de l'analyse de la simulation \@ref(fig:island-pca).

```{r island-manhattan, fig.cap='(ref:island-manhattan-cap)', echo=TRUE}
plot(x, option = "manhattan")
```

### Modèle de divergence

Nous adaptons une version du script Python utilisé dans [@roux2012recent], basé sur le module de simulation simuPOP [@peng2005simupop].

```{python simuPOP, cache = TRUE, echo = TRUE}
#!/usr/bin/env python
from __future__ import division
import simuOpt, types, os, sys, time
simuOpt.setOptions(alleleType = 'long')
from operator import itemgetter
import numpy as np
from simuPOP import *
from simuPOP.utils import *
from simuPOP.sampling import drawRandomSample

def simulate(Ne, Nsam, T1, T2, T3, s10, s11):
    pop = Population(size = Ne,
                     ploidy = 2,
                     loci = [1],
                     infoFields = ['fitness', 'migrate_to'])

    def getfitness10(geno):
        if geno[0] + geno[1] == 0 :
            return 1 - 2 * s10
        if geno[0] + geno[1] == 1 :
            return 1 - s10
        else :
            return 1

    def getfitness11(geno):
        if geno[0] + geno[1] == 0 :
            return 1 - 2 * s11
        if geno[0] + geno[1] == 1 :
            return 1 - s11
        else :
            return 1

    pop.evolve(
        initOps = [
            InitSex(),
            InitGenotype(loci = ALL_AVAIL,
                         freq = [0.5, 0.5],
                         begin = 0,
                         end = 1)
        ],

        preOps = [
            # resize the ancestral population at the time immediatly
            # before the split
            ResizeSubPops([0],
                          sizes = [Ne + Ne],
                          at = T1 - 1),

            ResizeSubPops(["S1_1"],
                          sizes = [Ne + Ne],
                          at = T1 + T2 - 1),

            # split populations in 2 subpopulations
            SplitSubPops(subPops = [0],
                         sizes = [Ne, Ne],
                         names = ["S1_0", "S1_1"],
                         at = T1),

            SplitSubPops(subPops = ["S1_1"],
                         sizes = [Ne, Ne],
                         at = T1 + T2,
                         names = ["S2_0", "S2_1"]),

            # apply selection by invoking function getfitness
            PySelector(loci = [0],
                       func = getfitness11,
                       begin = T1 + T2,
                       subPops = ["S2_1"]),

            PySelector(loci = [0],
                       func = getfitness10,
                       begin = T1,
                       subPops = ["S1_0"],
                       end = T1 + T2 + T3 - 1)
        ],

        matingScheme = RandomMating(ops = [
                                        Recombinator(intensity = 1)
                                    ]),

        gen = T1 + T2 + T3

    )

    sample = drawRandomSample(pop, sizes = [Nsam, Nsam, Nsam])

    return sample


Ne = 1000
Nsam = 25
T1 = 10
T2 = 100
T3 = 100
s = 0.1
nSNP = 10

G  = np.zeros([3 * Nsam, nSNP])

for i in range(nSNP):
    if i < 1:
        s10 = 2 * s
        s11 = 0.0
    elif i < 2:
        s10 = 0.0
        s11 = s
    else:
        s10 = 0.0
        s11 = 0.0
    res = simulate(Ne, Nsam, T1, T2, T3, s10, s11)
    for j in range(3):
        Sj = res.genotype(j)
        for k in range(int(len(Sj) / 2)):
            idx = j * int(len(Sj) / 2) + k
            G[idx][i] = Sj[2 * k] + Sj[2 * k + 1]

np.savetxt('data/simuPOP.pcadapt', G, fmt = '%i')
```

## Détails

### Données manquantes

Les données manquantes sont prises en compte à différentes étapes de la méthode, cela va de l'estimation de matrice de covariance à la régression linéaire multiple. Nous supposons que les données manquantes sont MAR (*missing at random*) ou MCAR (*missing completely at random*) et qu'elles ne dépendent donc pas de leur valeur (elles ne sont pas MNAR).

Pour chaque entrée de la matrice de covariance par individus, le calcul ne tient compte que des paires d'observations présentes.

Si $X_i$ et $X_j$ désignent deux individus, $\text{Cov}(X_i, X_j) = E[(X_i - \bar{X_i})(X_j - \bar{X_j})^T]$
Un estimateur de $\text{Cov}(X_i, X_j)$ tenant compte des valeurs manquantes donne
