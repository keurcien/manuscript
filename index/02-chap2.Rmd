# Introgression adaptative

Dans la partie précédente nous nous sommes intéressés à la détection d'allèles ayant favorisé l'adaptation d'une population à son environnement. Cependant, les scans génomiques pour la sélection ne permettent pas de comprendre l'origine du mécanisme adaptatif associé. Nous avons vu en introduction que la diversité allélique jouait un rôle important dans les processus d'adaptation locale, en offrant aux populations la possibilité de puiser dans un catalogue d'allèles plus vaste et d'augmenter ainsi leur potentiel adaptatif. Pour cette raison, l'introgression est désormais considérée comme un mécanisme d'adaptation important [@hedrick2013adaptive]. Nous rappelons que *l'introgression adaptative* correspond à la sélection d'allèles transmis par flux de gène ou par hybridation, ce qui permet de distinguer deux scénarios évolutifs distincts que nous décrivons ici. 

Le premier est un scénario de métissage où deux populations apparentées s'hybrident en donnant naissance à une nouvelle population, si bien que certains allèles provenant d'une des populations parentales peuvent être sélectionnés pour l'environnement dans lequel évolue la population métissée (Figure \@ref(fig:scenarii)). 

Le second scénario suppose l'entrée en contact d'une population dite donneuse avec une population dite receveuse, permettant à la population receveuse d'intégrer de nouveaux allèles (Figure \@ref(fig:scenarii)).

(ref:scenarii-cap) Scénarios d'introgression. À gauche une représentation schématique du modèle de métissage. À droite une représentation schématique du modèle à flux de gène. Dans les deux cas, la population jaune correspond à la population ayant bénéfié de gènes par introgression de la part de la population bleue.

```{r scenarii, results="asis", fig.cap="(ref:scenarii-cap)"}
include_graphics("figure/scenarii.png")
```

Nous présentons dans ce chapitre différents outils statistiques (Table \@ref(tab:software)) pour la détection de signaux d'introgression pour chacun des deux scénarios (Figure \@ref(fig:scenarii)), ainsi qu'une nouvelle approche basée sur l'Analyse en Composantes Principales valable pour les deux types de scénarios.

(ref:software-cap) Liste des méthodes et des logiciels présentés dans ce chapitre.

```{r software, results='asis', message=FALSE, eval=TRUE}
method <- c("Loter",
            "HAPMIX",
            "RFMix",
            "EILA",
            "*D*",
            "Bdf",
            "*f*",
            "RNDmin")

scenario <- c("Métissage",
              "Métissage",
              "Métissage",
              "Métissage",
              "Flux de gène",
              "Flux de gène",
              "Flux de gène",
              "Flux de gène")

ref <- c("Dias-Alves et al. (*in prep*)",
         "@price2009sensitive",
         "@maples2013rfmix",
         "@yang2013efficient",
         "@durand2011testing",
         "@pfeifer2017estimates",
         "@martin2014evaluating",
         "@rosenzweig2016powerful")

data.frame(method = method,
           scenario = scenario,
           ref = ref) %>%
  knitr::kable(col.names = c("Méthode",
                             "Scénario",
                             "Référence"),
               caption = '(ref:software-cap)',
               booktabs = TRUE,
               escape = TRUE) %>%
  kable_styling(full_width = T)
```

## Introgression par métissage

Nous nous intéressons ici à la détection de signaux d'introgression dans une population métissée, à partir de la donnée de coefficients de métissage locaux. Nous avons vu dans le paragrahe 2.2.3 qu'il était possible d'estimer pour un individu, la proportion de son génôme provenant d'un ou de plusieurs groupes génétiques. Ces proportions sont connues plus communément sous le nom de *coefficients de métissage* et peuvent servir à mieux comprendre l'histoire démographique des populations métisséees. De nombreux logiciels existent pour l'estimation de ces coefficients : STRUCTURE, ADMIXTURE [@alexander2009fast], LEA [@frichot2015lea], tess3r [@caye2016tess3]. Chaque individu peut de ce fait être vu comme une mosaïque d'allèles qui ont été puisés dans des groupes génétiques distincts. En revanche, les coefficients de métissage ne renseignent pas sur les portions du génôme qui proviennent effectivement de ces groupes génétiques.

### Coefficients de métissage locaux

Chercher à attribuer à chaque allèle la population ancestrale de laquelle il est originaire constitue la problématique d'estimation des *coefficients de métissage locaux* (Figure \@ref(fig:LAI)). Avoir à disposition une telle information individuelle et locale permet de quantifier à l'échelle de la population la probabilité qu'un allèle ait été fourni par une population spécifique. Ce type de méthodologie, basée sur l'estimation de coefficients de métissage locaux, a par exemple été employé pour la détection d'introgression adaptative chez les peupliers d'Amérique du Nord [@suarez2016]. Encore une fois, plusieurs logiciels ont été proposés dans le but d'estimer ces coefficients locaux : HAPMIX [@price2009sensitive], EILA [@yang2013efficient], LAMP [@thornton2014local], Loter (Dias-Alves et al., *in prep*) ou encore RFMix [@maples2013rfmix].


(ref:LAI-cap) Exemple de matrice de coefficients de métissage locaux pour des individus issus du métissage de deux populations sources (numérotées 1 et 2). **A**. Chaque ligne de la matrice correspond à un SNP et chaque haplotype est représenté par une colonne. **B**. Matrice de coefficients de métissage locaux individuels. Pour chaque nucléotide d'un haplotype, les méthodes d'estimation de coefficients de métissage locaux cherchent à attribuer ce nucléotide soit à la population 1 soit à la population 2.

```{r LAI, fig.cap='(ref:LAI-cap)', fig.height=3}
N <- 6
SNP.lab <- c("A", "T", "A", "A", "A", "A",
             "C", "C", "C", "A", "A", "A",
             "G", "T", "T", "G", "G", "G")
SNP.x <- rep(1:6, 3)
SNP.y <- c(rep(1, 6), rep(2, 6), rep(3, 6))

geno.lab <- c("2", "1", "2", "2", "2", "2",
              "1", "1", "1", "2", "2", "2",
              "1", "2", "2", "1", "1", "1")
geno.x <- rep(1:6, 3)
geno.y <- c(rep(1, 6), rep(2, 6), rep(3, 6))

ind <- rep(as.character(c(1, 1, 2, 2, 3, 3)), 3)

SNP.df <- data.frame(x1 = SNP.x,
                     x2 = SNP.x + 1,
                     y1 = SNP.y,
                     y2 = SNP.y + 1,
                     lab = SNP.lab,
                     ind = ind)

geno.df <- data.frame(x1 = geno.x,
                      x2 = geno.x + 1,
                      y1 = geno.y,
                      y2 = geno.y + 1,
                      lab = geno.lab,
                      ind = ind)

p1 <- SNP.df %>% 
  ggplot() +
  coord_fixed() +
  geom_rect(mapping = aes(xmin = x1,
                          xmax = x2,
                          ymin = y1,
                          ymax = y2,
                          fill = ind),
            color = "black",
            alpha = 0.75) +
  geom_text(aes(x = x1 + (x2 - x1) / 2,
                y = y1 + (y2 - y1) / 2,
                label = lab),
            size = 5) +
  scale_fill_manual(values = cbbPalette[c(3, 6, 7)]) +
  xlab("Haplotypes") +
  ylab("SNPs") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5))

p2 <- geno.df %>% 
  ggplot() +
  coord_fixed() +
  geom_rect(mapping = aes(xmin = x1,
                          xmax = x2,
                          ymin = y1,
                          ymax = y2,
                          fill = ind),
            color = "black",
            alpha = 0.75) +
  geom_text(aes(x = x1 + (x2 - x1) / 2,
                y = y1 + (y2 - y1) / 2,
                label = lab),
            size = 5) +
  scale_fill_manual(values = cbbPalette[c(3, 6, 7)]) +
  xlab("Haplotypes") +
  ylab("SNPs") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5))

geno.lab <- c("1", "0", "0",
              "0", "1", "2",
              "1", "1", "0")
geno.x <- rep(1:3, 3)
geno.y <- c(rep(1, 3), rep(2, 3), rep(3, 3))


geno.df <- data.frame(x1 = geno.x,
                      x2 = geno.x + 1,
                      y1 = geno.y,
                      y2 = geno.y + 1,
                      lab = geno.lab,
                      ind = rep(as.character(1:3), 3))

p3 <- geno.df %>% 
  ggplot() +
  coord_fixed() +
  geom_rect(mapping = aes(xmin = x1,
                          xmax = x2,
                          ymin = y1,
                          ymax = y2,
                          fill = ind),
            color = "black",
            alpha = 0.75) +
  geom_text(aes(x = x1 + (x2 - x1) / 2,
                y = y1 + (y2 - y1) / 2,
                label = lab),
            size = 5) +
  scale_fill_manual(values = cbbPalette[c(3, 6, 7)]) +
  xlab("Individus") +
  ylab("SNPs") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        plot.title = element_text(hjust = 0.5))


plot_grid(p1, p2, labels = c("A", "B"))
```

### Statistique de test

À partir de la matrice de coefficients de métissage locaux individuels, il est possible d'estimer pour un SNP donné la proportion d'allèles provenant de chacune des populations sources considérées. Pour estimer la proportion d'allèles provenant de la population $i$ pour le locus $j$, il suffit de calculer le nombre moyen de fois qu'un allèle observé sur le locus $j$ a été attribué à la population $i$ (un même individu présente deux allèles sur un locus donné (Figure \@ref(fig:LAI))). Notant $M$ la matrice de coefficients de métissage locaux individuels (Figure \@ref(fig:LAI), panel B), $G$ la matrice de génotypes (précisons que $M$ a deux fois plus de colonnes que $G$ car elle est de même dimension que la matrice des haplotypes) et $n$ le nombre d'individus métissés, la proportion d'allèles $p_{jk}$ provenant de la population $P_k$ au locus $j$ s'écrit :

\begin{equation}
  p_{jk} = \frac{1}{2n}\sum_{i=1}^n \delta_{M_{i, 2j-1}}^k + \delta_{M_{i, 2j}}^k
\end{equation}

où $\delta_x^k = 1$ si $x=k$ et $0$ sinon, $j=1,\dots,p$ où $p$ est le nombre de loci et $k=1,\dots,K$ où $K$ est le nombre de populations ancestrales. La proportion $p_{jk}$ désigne le coefficient de métissage local au locus $j$ à l'échelle de la population métisse. La recherche de régions d'introgression dans la population hybride se fait ensuite en regardant les coefficients de métissage locaux significativement élevés par rapport aux autres. Il n'y a pas de valeur standard pour le seuil de significativité, @suarez2016 choisissent par exemple un seuil de significativité de 3 écarts-types tandis que @fan2017epas1 optent pour un seuil de significativité de 2 écarts-types.

## Introgression par flux de gènes

La seconde classe de méthodes repose sur la comparaison de séquences de nucléotides, nucléotide par nucléotide. Un chromosome est par exemple divisé en un certain nombre de fenêtres (qui peuvent être disjointes ou chevauchantes), et les statistiques sont calculées sur chacune de ces fenêtres. Les séquences de nucléotides sont vues comme des chaînes de caractères et leur dissimilarité est mesurée à l'aide de distances classiques (ou de mesures de comptage) telles que la distance de Hamming.

### Diversité nucléotidique par paires de séquences

Soient $x = (x_i)_{1 \leq i \leq n}$ et $y = (y_i)_{1 \leq i \leq n}$ deux séquences de nucléotides. En particulier, $\forall i \in [|1, n|], \; x_i, y_i \in \{A, C, T, G \}$. La distance de Hamming $d_{xy}$ entre la séquence $x$ et la séquence $y$ est définie par :

\begin{equation}
  d_{xy} = \text{Card}(\{i \in [|1, n|] \; | \; x_i \neq y_i \})
\end{equation}

Pour étudier les similarités localement sur le génôme à l'échelle de populations, deux mesures naturelles peuvent être constuites à partir de $d_{xy}$, et consistent à calculer la distance moyenne et la distance minimale sur des séquences homologues provenant de différentes populations. Si $X$ (resp. $Y$) désigne l'ensemble des séquences de la population $P_1$ (resp. $P_2$), la distance moyenne et la distance minimale entre $X$ et $Y$ sont données par :

\begin{equation}
  \begin{split}
    d_{XY} &= \frac{1}{\text{Card}(X) \text{Card}(Y)}\sum_{x \in X} \sum_{y \in Y} d_{xy} \\
    d_{\min} &= \min_{(x,y) \in X \times Y} d_{xy}
  \end{split}
\end{equation}

$d_{XY}$ est appelée la *pairwise nucleotide diversity* et estime le nombre moyen de nucléotides différents entre une séquence venant de la population $X$ et une séquence venant de la population $Y$. $d_{\min}$ estime la distance minimale entre deux séquences tirées de $P_1$ et de $P_2$. Notons que $d_{XY}$ et $d_{\text{min}}$ étant symétriques, $X$ et $Y$ jouent des rôles équivalents, si bien que l'utilisation de ces distances pour détecter l'introgression ne permet pas de conclure sur le sens du flux de gène que l'on cherche à mettre en évidence. De plus, pour détecter l'introgression entre deux populations $X$ et $Y$ à partir de distances entre séquences nucléotidiques, la seule donnée de $d_{XY}$ ou de $d_{\min}$ ne suffit pas, une distance n'étant une mesure de proximité que si elle est mise en comparaison avec une autre distance. C'est pour cela que les statistiques d'introgression basées sur ce type de distance requièrent généralement la donnée d'une population de contrôle (appelée aussi *outgroup*), généralement notée $O$. C'est le cas par exemple des statistiques $RND$ [@feder2005mayr] et $RND\min$ [@rosenzweig2016powerful] définies ci-dessous :

\begin{equation}
  \begin{split}
    RND = \frac{2d_{XY}}{d_{XO} + d_{YO}} \\
    RND\min = \frac{2d_{\min}}{d_{XO} + d_{YO}}
  \end{split}
\end{equation}

Dans le cas de $RND\min$, une séquence sera donc détectée comme étant introgressée pour de faibles valeurs de $RND\min$.

### Le modèle ABBA-BABA 

L'emploi de ce modèle suppose l'accès à des séquences nucléotidiques provenant de quatre populations :

- une population donneuse.

- deux populations susceptibles de se reproduire avec la population donneuse.

- une population de contrôle avec qui toute possibilité de métissage est exclue.

Ces populations sont généralement présentées selon le schéma suivant (Figure \@ref(fig:123O)) :

(ref:123O-cap) Arbre allélique. $O$ désigne la population contrôle, $P_3$ la population donneuse, $P_1$ et $P_2$ les deux populations susceptibles de recevoir des allèles provenant de $P_3$.

```{r 123O, fig.cap='(ref:123O-cap)'}
triangle.x <- -c(-0.15, 1.05, 2.25)
triangle.y <- c(-0.15, 1.05, -0.15)

df.triangle <- data.frame(x = triangle.x, y = triangle.y)
df.branch.1 <- data.frame(x1 = -1.75, x2 = -1.25, y1 = 0.35, y2 = -0.15)
df.branch.2 <- data.frame(x1 = -1.4, x2 = -0.55, y1 = 0.7, y2 = -0.15)
df.triangle %>%
  ggplot(aes(x = x, y = y)) +
  geom_line(size = 4, colour = "#56B4E9") +
  geom_segment(data = df.branch.1,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  geom_segment(data = df.branch.2,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  ylim(-0.5, 1.1) +
  xlim(-3, 0.75) +
  coord_equal() +
  annotate("text",
           x = -c(-0.15, 0.55, 1.25, 2.25),
           y = c(-0.35, -0.35, -0.35, -0.35),
           label = c("O",
                     "P[3]",
                     "P[2]",
                     "P[1]"),
           hjust = 0, parse = TRUE, size = 5) +
  xlab("") +
  ylab("") +
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())
```

Sous l'hypothèse nulle, c'est-à-dire en l'absence d'introgression, la proportion de nucléotides communs à $P_3$ et $P_1$ doit être la même que la proportion de nucléotides communs à $P_3$ et à $P_2$. À l'inverse, un évènement d'introgression entre $P_3$ et $P_1$ devrait s'accompagner de l'augmentation de la fraction de séquences partagées par $P_3$ et $P_1$, relativement à $P_2$. Cette différence de proportions est mesurée par la statistique $D$ de Patterson [@durand2011testing], conçue spécifiquement pour détecter l'introgression de manière globale sur le génôme. De façon plus imagée, notant $A$ et $B$ respectivement les allèles portés par $O$ et par $P_3$, la statistique $D$ compte le nombre de motifs $ABBA$ (Figure \@ref(fig:abba-baba)) et le nombre de motifs $BABA$ (Figure \@ref(fig:abba-baba)) et teste si les deux quantités sont significativement différentes l'une de l'autre.

(ref:abba-baba-cap) **A.** À gauche un arbre allélique présentant un motif $ABBA$ indiquant que l'allèle $B$ présent dans la population $P_2$ a été hérité de la population $P_3$. **B.** À droite un arbre allélique présentant un motif $BABA$ indiquant que l'allèle $B$ présent dans la population $P_1$ a été hérité de la population $P_3$.

```{r abba-baba, fig.cap='(ref:abba-baba-cap)', fig.height=3}
triangle.x <- -c(-0.15, 1.05, 2.25)
triangle.y <- c(-0.15, 1.05, -0.15)

df.triangle <- data.frame(x = triangle.x, y = triangle.y)
df.branch.1 <- data.frame(x1 = -1.75, x2 = -1.25, y1 = 0.35, y2 = -0.15)
df.branch.2 <- data.frame(x1 = -1.4, x2 = -0.55, y1 = 0.7, y2 = -0.15)
p1 <- df.triangle %>%
  ggplot(aes(x = x, y = y)) +
  geom_line(size = 4, colour = "#56B4E9") +
  geom_segment(data = df.branch.1,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  geom_segment(data = df.branch.2,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  ylim(-0.75, 1.1) +
  xlim(-3, 0.75) +
  coord_equal() +
  annotate("text",
           x = -c(-0.15, 0.55, 1.25, 2.25,
                  -0.15, 0.55, 1.25, 2.25),
           y = c(-0.35, -0.35, -0.35, -0.35, 
                 -0.65, -0.65, -0.65, -0.65),
           label = c("bold(A)",
                     "bold(B)",
                     "bold(B)",
                     "bold(A)",
                     "(O)",
                     "(P[3])",
                     "(P[2])",
                     "(P[1])"),
           hjust = 0.5, parse = TRUE, size = 5) +
  xlab("") +
  ylab("") +
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())

p2 <- df.triangle %>%
  ggplot(aes(x = x, y = y)) +
  geom_line(size = 4, colour = "#56B4E9") +
  geom_segment(data = df.branch.1,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  geom_segment(data = df.branch.2,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  ylim(-0.75, 1.1) +
  xlim(-3, 0.75) +
  coord_equal() +
  annotate("text",
           x = -c(-0.15, 0.55, 1.25, 2.25,
                  -0.15, 0.55, 1.25, 2.25),
           y = c(-0.35, -0.35, -0.35, -0.35, 
                 -0.65, -0.65, -0.65, -0.65),
           label = c("bold(A)",
                     "bold(B)",
                     "bold(A)",
                     "bold(B)",
                     "(O)",
                     "(P[3])",
                     "(P[2])",
                     "(P[1])"),
           hjust = 0.5, parse = TRUE, size = 5) +
  xlab("") +
  ylab("") +
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())

plot_grid(p1, p2, labels = c("A", "B"))
```

La statistique $D$ de Patterson, définie à partir des motifs $ABBA$ et $BABA$, est donnée par la relation suivante :

\begin{equation} 
  D = \displaystyle \frac{\sum_i C_{ABBA}(i) - C_{BABA}(i)}{\sum_i C_{ABBA}(i) + C_{BABA}(i)} 
\end{equation}

où $C_{ABBA}(i)$ (resp. $C_{BABA}(i)$) désigne le nombre de motifs $ABBA$ (resp. $BABA$) observés sur le site $i$. Selon @martin2014evaluating, cette statistique présente le défaut de trouver des outliers dans des régions à faible diversité allélique qui ne sont pas nécessairement introgressées. Partant de ce constat, de nombreuses variantes ont été développées à partir de cette statistique, dont les statistiques $Bd_{f}$ [@pfeifer2017estimates] et $f_d$ [@martin2014evaluating] auxquelles nous nous comparons, afin de corriger les défauts de la statistique $D$. 

## Une nouvelle statistique pour les scans d'introgression

### Analyse en Composantes Principales locale

Les méthodes de détection d'introgression que nous avons présentées, aussi bien dans un scénario de métissage que dans un scénario à flux de gènes (Figure \@ref(fig:scenarii)), reposent sur le même principe, à savoir que dans une zone d'introgression les motifs observés diffèrent significativement de ce qui est observé à l'échelle globale (soit en termes de coefficients de métissage, soit en termes de motifs d'arbre allélique). 

Nous proposons dans ce paragraphe d'utiliser les scores de l'ACP en tant que motif de comparaison, ceci étant justifié par le fait que le métissage à l'échelle du génôme peut être estimé à partir des scores des individus métissés [@mcvean2009genealogical]. Notant $B$ le barycentre des scores des individus d'une population métissée $P$, et $B_1$ (resp. $B_2$) le barycentre des scores des individus appartenant à la population $P_1$ (resp. $P_2$), nous pouvons estimer la proportion globale de métissage de $P$ relativement à $P_1$ et $P_2$ en calculant les coordonnées barycentriques de $B$ dans le repère ($B_1$, $B_2$), c'est-à-dire en déterminant les coefficients $q_1$ et $q_2$ tels que $B = q_1 B_1 + q_2 B_2$ avec $q_1 + q_2 = 1$. 

À l'échelle locale, nous pourrions également définir de tels coefficients barycentriques, à la condition de pouvoir définir des *scores locaux*. Dans la littérature, nous trouvons deux façons de définir de tels scores :

- les scores de l'ACP réalisée sur des sous-ensembles de SNPs [@li2016local; @fan2017epas1]. Cette approche revient à fenêtrer le génôme et à réaliser l'ACP sur chacune des fenêtres.

- les scores locaux de l'ACP. Cette approche à trouver les loadings en faisant une ACP classique sur l'ensemble du génôme, puis les scores locaux sont obtenus en ne prenant en compte que les loadings de la fenêtre considérée. Dit autrement, cela revient à calculer les coefficients de la régression de $\tilde{G}$ par un sous-ensemble de loadings $\Sigma V^T$ où $\tilde{G} \simeq U \Sigma V^T$ est la décomposition en valeurs singulières de la matrice de génotypes normalisée. Ces coefficients de régression sont par ailleurs appelés *scores de métissage* par @brisbin2012pcadmix. 

Nous choisissons ici d'utiliser la seconde approche basée sur les coefficients de régression, principalement parce que la première n'est pas adaptée au cas de données génétiques denses. Une approche par fenêtre glissante nécessiterait de réaliser un nombre d'ACP locales équivalent au nombre de marqueurs présents, soit une complexité en $O(np^2)$ (où $n$ désigne le nombre d'individus et $p$ le nombre de marqueurs génétiques), contrairement à la seconde méthode qui peut être implémentée en temps linéaire par rapport à $n$ et à $p$ (voir annexe). Notant $i$ un entier compris entre $1$ et $p$, et $x_i$ la position génétique (mesurée en Morgans) ou la position physique (mesurée en paires de bases) du $i$-ème marqueur génétique. Nous définissons pour cet entier $i$ la fenêtre $W_i^T$ de taille $T$ et centrée en $i$ par :

\begin{equation}
  W_i^T = \{ j \in [|1, p|], |x_i - x_j| \leq T/2 \}
\end{equation}

Soit $\tilde{G} = U \Sigma V^T$ la décomposition en valeurs singulières de la matrice de génotypes normalisée $\tilde{G}$. Partant de l'approximation $U \simeq \tilde{G}V\Sigma^{-1}$, les scores de métissage sont définis de la façon suivante [@brisbin2012pcadmix] :

\begin{equation}
  U_{W_i^T} = \tilde{G}_{.,W_i^T}V_{W_i^T,.}\Sigma^{-1}
\end{equation}

Les proportions de métissage local de la population $B_{W_i^T}$ sont définies de la même façon que dans le cas global, à la différence qu'elles utilisent les scores locaux $U_{W_i^T}$ à la place des scores globaux $U$. Ainsi, une région sera alors considérée comme introgressée si les proportions de métissage locale calculées sur cette région sont significativement différentes des proportions de métissage calculées à l'échelle du génôme.

### Résultats principaux

**Nous proposons une méthode spécifiquement dédiée à la détection d'introgression.** Le développement d'une méthode destinée spécifiquement à la détection d'introgression est motivé par le fait que des méthodes basées sur l'estimation de coefficients de métissage nécessitent de disposer d'informations parfois difficiles à obtenir comme la phase des haplotypes. Le problème de la détection d'introgression étant plus simple que celui de l'estimation des coefficients de métissage local, nous proposons une approche qui permet de s'affranchir d'étapes relativement lourdes telles que la détermination des haplotypes et de leur phase, allégeant considérablement le temps de calcul nécessaire. À l'aide de simulation numérique réalisées pour les deux types de scénarios d'introgression présentés, nous montrons que notre statistique produit un taux de fausses découvertes et une puissance comparables aux méthodes de l'état de l'art (Figure \@ref(fig:power-admix)), en utilisant seulement la donnée de génotypes.

**Application au jeu de données de peupliers.** Nous avons testé notre méthode sur un jeu de données de peupliers d'Amérique du Nord [@suarez2016]. Deux populations de peupliers ont été génotypées, *Populus balsamifera* qui est une population adaptée aux conditions boréales et *Populus trichocarpa* qui est une population adaptée au climat doux du Nord-Ouest américain [@suarez2016]. Comme @suarez2016, nous avons regardé pour des individus métisses avec une ascendance génétique *Trichocarpa* majoritaire, les régions de leur génôme présentant un excès d'ascendance génétique *Balsamifera* qui leur permet de s'adapter à des conditions plus froides et sèches. Nous trouvons la même région d'introgression sur le chromosome 6 que @suarez2016 (Figure \@ref(fig:chr06-100kbp)). Pour le chromosome 15 nous trouvons les mêmes régions candidates. En revanche, nous trouvons deux nouvelles régions candidates pour le chromosome 12 (Figure \@ref(fig:chr12-100kbp)), qui sont également détectées avec RFMix [@maples2013rfmix] et l'une d'entre elles est détectée avec Loter. Cette différence de résultats peut être due au prétraitement des données de génotypes. @suarez2016 ont appliqué des filtres enlevant près de $95\%$ du jeu de données initial, tandis que nous avons choisi de ne filtrer que les SNPs présentant plus de $5\%$ de données manquantes, ce qui permettait de conserver plus de $70\%$ du jeu de données initial.

(ref:chr06-100kbp-cap) Résultats du scan d'introgression obtenus sur le chromosome 6 du jeu de données de peupliers [@suarez2016] avec différentes méthodes basées sur l'estimation des coefficients de métissage locaux.

```{r chr06-100kbp, results='asis', fig.cap='(ref:chr06-100kbp-cap)'}
include_graphics("figure/Chr06_100kbp.png")
```

(ref:chr12-100kbp-cap) Résultats du scan d'introgression obtenus sur le chromosome 6 du jeu de données de peupliers [@suarez2016] avec différentes méthodes basées sur l'estimation des coefficients de métissage locaux.

```{r chr12-100kbp, results='asis', fig.cap='(ref:chr12-100kbp-cap)'}
include_graphics("figure/Chr12_100kbp.png")
```

\newpage

## Article 3

### Introduction {-}

A potential source of adaptive genetic variation is adaptive introgression. Adaptive introgression occurs when selectively beneficial alleles are transferred between species [@arnold2009adaptation; @dasmahapatra2012butterfly; @fraisse2014gene]. Although adaptive genetic variation originates primarily from de novo mutation or standing variation, adaptive introgression is now acknowledged as an important source of genetic variation in plants but also in animals [@hedrick2013adaptive].

To model adaptive introgression, there are at least two conceptual evolutionary scenario. In the first "admixture" scenario, two populations or two related species  admixed to form a new hybrid population (Figure \@ref(fig:scenarios)). Adaptive introgression occurs when variation from one of the source population is adaptive in the environment of the admixed population. For instance, Tibetans are the results of admixture between Han and Sherpa populations, and alleles that confer adaptation to high altitude have been transmitted by the Sherpa population [@jeong2014admixture]. Evidence of adaptive introgression following admixture has been provided in several admixed populations or species, including Africanized honeybee, Populus species, North American canids, or human Bantu-speaking populations to name just a few examples [@payseur2016genomic; @suarez2016; @vonholdt2016admixture; @patin2017dispersals; @nelson2017genome]. The second evolutionary scenario assumes "gene flow" or "introgression" from a donor species to an introgressed species (Figure \@ref(fig:scenarios)). For instance, house mice became resistant to a warfarin pesticide because of selection on VKORC1 polymorphisms that has been acquired from the Algerian mouse (*M. spretus*) through introgression [@song2011adaptive]. Another classical example of introgression followed by adaption include colour adaptations in Heliconius species [@pardo2012adaptive]. Whereas detection of loci involved in adaptive introgression are performed with different statistical methods for the admixture and gene flow evolutionary models, we propose a statistical approach that is valid in both evolutionary models.

In the admixture model, outlier loci are found by looking for genomic regions harboring excess of ancestry from the donor population [@buerkle2008admixture]. Excess of ancestry are obtained using local ancestry inference (LAI) that computes for admixed individuals the number of chromosome copies coming from the ancestral populations. There are several software available for LAI including EILA, HAPMIX, LAMP-LD, or RFMIX [@baran2012fast; @jeong2014admixture; @maples2013rfmix; @price2009sensitive]. Except for EILA, LAI software can require biological information that can be difficult to obtain especially for non-model species. For instance, HAPMIX or RFMIX require phased haplotypes for the ancestral populations and RFMIX also require phased haplotypes for the admixed individuals. In addition, a recombination map and an estimate of the admixture date between the ancestral populations should be provided for both HAPMIX and RFMIX [@baran2012fast; @jeong2014admixture; @maples2013rfmix; @price2009sensitive].

In the "gene flow" or "introgression" scenario, there have also been attempts to find introgressed regions with outlier detection methods [@rheindt2013introgression; @smith2013heliconius; @zhang2016genome]. A common approachis to test for an excess of shared derived variants in the donor and recipient populations using the $D$ or ABBA-ABBA test statistic [@durand2011testing]. However, extreme $D$ values occur disproportionately in genomic regions with lower diversity [@martin2014evaluating].  Because genome scans with the $D$ statistic generates too many false positives, more powerful statistics have been developed such as the $f_D$ or $BDF$ statistic [@martin2014evaluating; @pfeifer2017estimates]. In addition, the $D$ statistic and its extensions cannot be used to identify introgressed regions between sister species (see Figure x panel B); it should be used with three or more lineages to detect the different topologies produced by hybridization [@rosenzweig2016powerful]. To identify introgression between sister species, various alternative statistics have been developed including $RND_{min}$, which computes the minimum pairwise distance between the two sister species relative to the divergence to an outgroup. By contrast, to the $D$ statistic and its extension, $RND_{min}$ requires phased data [@rosenzweig2016powerful].

We propose a statistical method to detect candidates for adaptive introgression that is valid in both the admixture scenario and the introgression scenarios. The proposed approach is based on principal component analysis (PCA), which is well-suited to ascertain population structure of large scale  genome-wide dataset [@patterson2006population; @mcvean2009genealogical]. Numerical solutions to compute principal component scores can be obtained rapidly even with large scale data [@duforet2015detecting; @galinsky2016fast; @abraham2017flashpca2]. The proposed approach does not require any biological information in addition to the genome-wide genotype data and should therefore be valuable especially for non-model species where recombination map are not available and where haplotype phasing can be a daunting task. The statistical method we propose ascertains population structure locally in the genome by computing local principal components. Candidate SNPs for local introgression correspond to genomic regions for which population structure of the admixed or introgressed population deviates significantly from genome-wide population structure (Figure \@ref(fig:scenarios)). To capture population structure of the admixed or introgressed individuals with respect to the other individuals, the method computes an average ancestry coefficient. In the following, we investigate to what extent the PCA-based approach provides an alternative to LAI and to the aforementioned phylogenetic statistics in the admixture and introgression scenario. We show the potential of the method to detect adaptive introgression in a hybrid *Populus* species resulting from a 2-way admixture model [@suarez2016] TO COMPLETE. The PCA-based method is implemented in the R package pcadapt [@luu2017pcadapt].

### Materials and methods {-}

#### A PCA-based approach to detect local introgression {-}

The objective of PCA is to find a new set of orthogonal variables called the principal components, which are linear combinations of (centered and standardized) allele counts, such that the projections of the data onto these axes lead to an optimal summary of the data. To present the method, we introduce the truncated singular value decomposition (SVD) that approximates the $(n \times p)$ centered and scaled genotype matrix ${\bf Y}$ by a matrix of smaller rank

\begin{equation}
  {\bf Y}\approx{\bf U}{\bf \Sigma} {\bf V}^T,
  (\#eq:svd-intro)
\end{equation}

where ${\bf U}$ is a $(n \times K)$ orthonormal matrix, ${\bf V}$ is a $(p \times K)$ orthonormal matrix, ${\bf \Sigma}$ is a diagonal $(K \times K)$ matrix and $K$ corresponds to the rank of the approximation. The solution of PCA with $K$ components can be obtained using the truncated SVD of equation \@ref(eq:svd-intro): the $K$ columns of ${\bf V}$ contain the loadings, which correspond to the contribution of each SNP to the PCs and the $K$ columns of ${\bf U}$ contain the PC *scores* that are usually displayed to visualize population structure [@patterson2006population; @duforet2015detecting].

To provide local measure of population structure, we compute local PCA scores. For a SNP $j$, we compute the vector of *local scores* ${\bf U_j}$ that measures population structure locally in the genome

\begin{equation}
  {\bf U}_j = {\bf Y_j}{\bf V_j}{\bf \Sigma}^{-1},
  (\#eq:local-scores)
\end{equation}

where ${\bf Y_j}$ correspond to the genotype restrained to a genomic window around SNP $j$ and ${\bf V_j}$ corresponds to the loadings restrained to a genomic window around SNP $j$. RAJOUTER CALCUL ONLINE DES SCORES.

An average local ancestry coefficient $q$ is then obtained from the local scores ${\bf U}_j$ using barycentric coordinates for the barycenter $B$ of the local scores of admixed or introgressed individuals. Barycentric coordinates of $B$ correspond to the $K$ coefficients $q_1,\dots,q_K$ ($q_1+\dots+q_K=1$) such as $B$ can be written as a linear combination $B = q_1 B_1 + \dots + q_K B_K$ where $B_1, \dots, B_K$ are the barycenters of local scores for the $K$ source populations. In the admixture scenario, barycentric coordinates are always between 0 and 1 because local scores of admixed individuals are always contained in the simplex determined by the barycenters of the ancestral populations (Figure \@ref(fig:admixture)). By contrasts, barycentric coordinates can be negative or larger than 1 for the introgression scenario (\@ref(fig:introgression)). To find outlier regions with excess of ancestry from the donor population $j$ that is one of the $K$ source populations, we compute robust mean $\mu_j$ and variance $\sigma^2_j$ of the average ancestry coefficients using the median absolute deviation and we consider the standardized average ancestry coefficient $(q_j - \mu_j) / \sigma_j$, $j = 1, \dots, K$.

#### Parameter settings for local ancestry and adaptive introgression software {-}

For the admixture scenario, we consider three software of local ancestry inference, which are EILA, Loter and RFMix [@maples2013rfmix; @yang2013efficient]. EILA considers genotypes as input and we consider a regularization parameter of $\lambda=0.1$. Loter uses haplotypes as input data and has no tuning parameter. RFMix uses haplotypes as input data and we consider the default parameter except the window size that was set at 0.002cm. Using the default window size generates error message and as recommended by the manual of RFMix, we reduce window size to overcome this issue. When analyzing Populus data, we consider the same averaging strategy as implemented in the initial analysis with RASPberry and average local ancestry coefficients obtained with RFMix and loter using 250kb windows [@suarez2016].

For the introgression scenario, we compared pcadapt to the $Bd_f$, $D$, $f_D$, and $RND_{min}$ test statistics [@durand2011testing; @martin2014evaluating; @pfeifer2017estimates; @rosenzweig2016powerful]. The $D$, $Bd_f$ and $f_D$ statistics require genotype data for the three related species as well as from an outgroup species, for which we also simulate genotypes (\@ref(tab:stats_introgression)). Because $RND_{min}$ tests for introgression between sister species, we provide sequence (haplotype) data from 3 species, which are the introgressed, and donor species as well as an outgroup species (Figure \@ref(fig:scenarios)). When using pcadapt, we provide genotype data from three species, which are introgressed, donor and sister species (Figure \@ref(fig:scenarios)).

(ref:scenarios-cap) Principal components obtained for a neutral region and an outlier region in the admixture scenario (left panels) and in the introgression scenario (right panels). For the admixture scenario, simulations use phased genotype data from *P. balsamifera* and *P. trichocarpa* individuals and we assume that the difference $\Delta_q$ of ancestry between outlier and neutral regions is of $50\%$ and that admixture took place $\lambda = 100$ generations ago. For the introgression scenario, the gene flow parameter $f = 0.5$.

```{r scenarios, results='asis', fig.cap='(ref:scenarios-cap)'}
include_graphics("figure/pca.png")
```

#### Simulations under an admixture scenario {-}

We consider the example of admixture of two *Populus* species in North America to simulate admixed individuals [@suarez2016]. We considered genotypes from chromosome 6 of $25$ individuals from the species *Populus balsamifera}* (balsam poplar) and $25$ individuals from the species *Populus trichocarpa* (black cottonwood) [@suarez2016]. In order to generate admixed individuals, we phase the 50 genotypes using BEAGLE [@browning2007rapid]. To construct admixed genomes, we began at the first marker on each chromosome and sampled *Populus balsamifera* ancestry with probability $\alpha=70\%$ and *Populus trichocarpa* ancestry with probability $(1 - \alpha) = 30\%$. Haplotype of the admixed genome was form by sampling at random one of the haplotype coming from the *P. balsamifera* or *P. trichocarpa* species. Ancestry was resampled based on an exponential distribution with weight $\lambda$, which corresponds to the number of generations since admixture [@price2009sensitive]. A new ancestry tract was sampled with probability $1 - e^{-\lambda g}$ when traversing a genetic distance of $g$ Morgans. Each time ancestry was resampled, we sampled *P. balsamifera* ancestry with probability $\alpha = 70\%$ and *P. trichocarpa* ancestry with probability $(1 - \alpha) = 30\%$. In the simulations, we consider the first $100,000$ SNPs of the chromosome 6 of Populus individuals. To model adaptive introgression, we assume that there is a region containing $1,000$ SNPs where *P. balsamifera* ancestry was equal to $70\%-\Delta_q$ instead of $70\%$. We consider different values for $\Delta_q$ which are equal to $5\%$, $10\%$, $15\%$, $20\%$, $30\%$, $40\%$, or $50\%$. Simulations correspond to a model of soft sweep where different alleles of *P. balsamifera* ancestry, which span the $500$ SNPs genomic regions, are adaptive [@messer2013population]. Because there is no recombination map available in *Populus*, we assume a constant recombination rate of 0.05cM/Mbp [@suarez2016]. We consider three different values for the time since admixture $\lambda$, which is equal to $10$, $100$, or $1000$ generations. For each value of $\lambda$ and of $\Delta_q$, we generate $50$ replicates containing $25$ admixed individuals each. When looking for adaptive introgression in admixed *P. trichocarpa* individuals, we consider $1,418,814$ SNPs typed in $36$ admixed individuals [@suarez2016].

#### Simulations under an introgression scenario {-}

We consider simulations of introgression as described by [@martin2014evaluating]. To simulate genomes, we concatenate 45 $5,000$ bp regions without introgression and 5 $5,000$ bp regions where each individuals from the introgressed species is drawn from the donor population with a probability $f$ (Supplementary Figure \@ref(fig:introgression)). The parameter $f$ measures the extent of introgression for introgressed regions. When $f = 1$ all individuals from the introgressed species come from the donor population and $f = 0$ correspond to the genomic windows without introgression. The *ms* command lines for simulating neutral and introgressed ($f = 20\%$) regions for $25$ individuals in each population are given as follows [@hudson2002generating]

```
./ms 200 1 -I 4 50 50 50 50

-ej 1 2 1 -ej 2 3 1 -ej 3 4 1

-r 50 5000 -T #non-introgressed

./ms 200 1 -I 4 50 50 50 50

-ej 1 2 1 -ej 2 3 1 -ej 3 4 1 -es 0.2 2 0.8 -ej 0.2 5 3

-r 50 5000 -T #introgressed
```

Sequence data were then generated using the software Seq-Gen using the Hasegawa-Kishino-Yano substitution model and a branch scaling factor of 0.01 ( `./seq-gen -mHKY -l 5000 -s 0.01`) [@rambaut1997seq].

#### Evaluation rules for simulations {-}

For admixture scenarios, we consider the 50,000 first SNPs of chromosome 6 when evaluating different software. To evaluate statistical power, we consider 50 windows containing 1,000 SNPs each. To compute a score for each window, we consider two methods: averaging ancestry coefficients over all SNPs within a window or considering the maximum of ancestry coefficients within a window. For a fixed number of regions considered as outliers, we report statistical power defined as the average over simulations of the number of detected outlier regions divided by five, which are the true number of outlier regions.

For introgression scenarios, we simulated 50 windows of $5,000$ bp. All statistics but pcadapt are computed using $5,000$ bp windows. Statistical power is returned when considering the 5 top hits, which corresponds to the 5 largest values of the test statistics.

### Results {-}

#### Simulations under an admixture scenario {-}

For a simulated admixture scenario between two *Populus* species, we display standardized ancestry coefficients computed by pcadapt and LAI software (Supplementary Figure \@ref(fig:ancestry)). When simulating admixed individuals, we assume that there are five outlier regions where the amount of *P. trichocarpa* ancestry is increased by an amount of $\Delta_q$ compared to other regions. In the genome scans where $\Delta_q=xx$ and admixture occurred $\lambda = xx$ generations ago, the top 5 peaks obtained with all software correspond to the peaks that should be detected (Figure \@ref(fig:ancestry)). The power of LAI software based on haplotypes (Loter and RFMix), when varying values of $\Delta_q$ and of $\lambda$, is comparable to the power obtained by an ideal method called *oracle*, which would know ancestry chunks for each admixed individual (Figure \@ref(fig:power-admix)). For Loter, the loss of power---averaged over $\Delta_q$---is comprised between $1\%$ and $19\%$ depending on the number of generations since admixture (Supplementary Figure \@ref(fig:losspower-admix)). For RFMix, the loss of power is comprised between $3\%$ and $11\%$. When considering methods based on genotypes, we find that the power obtained with EILA is considerably reduced compared to an oracle because loss of power is always larger than $55\%$. When considering other values of the regularization parameter $\lambda$ for EILA, statistical power was further reduced. By contrast, the power of pcadapt is comparable to the power obtained with haplotype-based methods. Compared to an oracle, the loss of power of pcadapt is comprised between $3\%$ and $7\%$. The power of pcadapt is increased compared to haplotype-based methods for ancient admixture events ($\lambda=1,000$ generations) whereas it is decreased for recent admixture events ($\lambda=10$ generations) (Figure \@ref(fig:power-admix)). Because we evaluate statistical power on a genomic region-by-region basis, we had to define a compound ancestry measure for each genomic region and Figure \@ref(fig:power-admix) correspond to results obtained when considering the averaging ancestry coefficient within each genomic region. If we rather compute the maximum of ancestry coefficients within each window, the power of pcadapt is again increased compared to haplotype-based methods for ancient admixture events whereas results are more balanced for recent admixture events (Supplementary Figure \@ref(fig:power-admix-max)). Although pcadapt considers genotypes only, we find that it provides statistical power comparable to LAI software that make use of haplotypes. When considering additional hits to the five top hits, the statistical power of pcadapt is again comparable to the one obtained with haplotype-based methods (Supplementary Figure \@ref(fig:si-power-admix)).

(ref:power-admix-cap) Proportion of true outlier peaks among the five top peaks found with pcadapt and different LAI methods (EILA, Loter and  RFMix) in a scenario where 2 Populus populations experienced admixture. Proportion of true outlier peaks is displayed as a function of the difference $\Delta_q$ of ancestry between outlier and neutral regions. The three panels correspond to the three different possible values ($\lambda=10$ or $100$ or $1000$) of the number of generations since admixture.

```{r power-admix, results='asis', fig.cap='(ref:power-admix-cap)'}
include_graphics("figure/power_Dq.png")
```

#### Adaptive introgression in Populus admixed individuals {-}

We replicated the search for adaptive introgression in admixed Populus species [@suarez2016]. We searched for genomic regions with excess of *P. balsamifera* ancestry (boreal species) in admixed *P. trichocarpa* individuals (temperate species). We compare outlier regions found with RFMix, pcadapt and Loter to the regions already found by @suarez2016 with the software RASPberry, which implements the HAPMIX model for local ancestry. All software found the peak in chromosome 6 that is located 3.36Mb away from the start of the chromosome (\@ref(fig:ancestry_chr6)) [@suarez2016]. In addition to this peak, there are 2 additional peaks above the 3 s.d. threshold that are found with pcadapt. These peaks are also found with RFMix and one of this peak is at 2.5 s.d. when using Loter. The first peak corresponds to a 200kbp region that starts at 14.150 Mb away from the start of the chromosome and the second peak corresponds to a 150 kbp region that starts at 15,500,500bp away from the start. The functional annotation of the transcript Potri.006G161900.1 found in the second region is "Vernalization intensive protein" and vernalization is a trait known to be involved in an adaptation to extreme winter in Arabidopsis [@duncan2015seasonal]. The list of other transcripts and of corresponding functional annotations are provided in Supplementary Table \@ref(tab:annotation).

#### Simulations under an introgression scenario {-}

We compared power of several introgression statistics in introgression scenarios. When the proportion $f$ of introgression for introgressed region is equal to 1, all individual from the introgressed population descend from the donor population. In this situation of massive introgression, the power of all statistics is equal to $100\%$ except for the $D$ statistics, which has a power of $94\%$ (Figure \@ref(fig:power_introgression)). The power of all statistics remains at $100\%$ when $f \geq 0.7$ except the $D$ statistic whose power decreases to $80\%$ for $f = 80\%$. When $f$ further decreases, powers of all statistics also decrease with the $D$ statistics being the less powerful statistic. The more powerful statistics is $RND_{min}$, followed by $f_D$, $Bd_f$, and pcadapt. For the most difficult scenarios where $f = 5\%$, the power of $RND_{min}$ is $68\%$, the power of $f_d$ is $64\%$, the power of $Bd_f$ is $60\%$, the power of pcadapt is $56\%$ and the power of $D$ is $38\%$.

We consider *Populus* simulated admixed individuals to evaluate if the PCA-based approach manages to identify true outliers for local ancestry. By considering the 5 peaks with highest values of local ancestry, we compare statistical power obtained with the PCA-based approach and with LAI software. For each software, statistical power decreases as a function of $\Delta_q$ as it was expected (Figure \@ref(fig:power-admix)). Among all software we consider, RFMix and Loter maximize statistical power whatever the value of the time since admixture $\lambda$ and of the difference of allele frequency between introgressed and non-introgressed regions (Figure \@ref(fig:power-admix)). Although the power of the PCA approach is reduced, the loss of power is very small because the relative loss of power when compared to RFMix or Loter is comprised between $xx\%$ and $xx\%$. By contrast, the reduction of power obtained with EILA, which is another method that use genotype only, is considerable because it ranges between $xx\%$ and $xx\%$ when compared to Loter.

#### Comparison with software for Local Ancestry Inference {-}

### Discussion {-}

(ref:power-chr6-cap) Standardized average *Populus balsamifera* ancestry coefficient computed with pcadapt, Loter, RFmix, and RASPberry for admixed *Populus trichocarpa* individuals at chromosome 6. We report the RASPberry genome scan that has initially been performed to detect adaptive introgression and which is based on 77,447 SNPs [@suarez2016]. Genome scans reported with all other software are based on 1,418,814 SNPs.

```{r power-chr6, results='asis', fig.cap='(ref:power-chr6-cap)'}
include_graphics("figure/Chr06_window_size_250kbp.png")
```

```{r}
triangle.x <- c(-0.15, 1.05, 2.25)
triangle.y <- c(-0.15, 1.05, -0.15)

df.triangle <- data.frame(x = triangle.x, y = triangle.y)
df.branch <- data.frame(x1 = 1.6, x2 = 0.95, y1 = 0.5, y2 = -0.15)

p1 <- df.triangle %>%
  ggplot(aes(x = x, y = y)) +
  geom_line(size = 4, colour = "#56B4E9") +
  geom_segment(data = df.branch,
               aes(x = x1, y = y1, xend = x2, yend = y2),
               size = 4,
               colour = "#56B4E9") +
  ylim(-1.1, 1.1) +
  xlim(-0.75, 3) +
  annotate("text",
           x = c(-0.5, 0.75, 2,
                 rep(-0.5, 6),
                 rep(0.75, 8),
                 rep(2, 8)),
           y = c(-0.25, -0.25, -0.25,
                 -0.35, -0.45, -0.55, -0.65, -0.75, -0.85,
                 -0.35, -0.45, -0.55, -0.65, -0.75, -0.85, -0.95, -1.05,
                 -0.35, -0.45, -0.55, -0.65, -0.75, -0.85, -0.95, -1.05),
           label = c("bold(Diplotaxodon)",
                     "bold(Deep~benthic)",
                     "bold(Shallow~benthic)",
                     "italic(Diplotaxodon~greenwoodi)",
                     "italic(Diplotaxodon~limnothrissa)",
                     "italic(Diplotaxodon~macrops)",
                     "italic(Diplotaxodon~macrops~black~dorsal)",
                     "italic(Diplotaxodon~ngulube)",
                     "italic(Diplotaxodon~white~back~similis)",
                     "italic(Lethrinops~longimanus~redhead)",
                     "italic(Lethrinops~sp~oliveri)",
                     "italic(Alticorpus~macrocleithrum)",
                     "italic(Aulonocara~minutus)",
                     "italic(Alticorpus~geoffreyi)",
                     "italic(Aulonocara~yellow)",
                     "italic(Aulonocara~steveni)",
                     "italic(Aulonocara~stuartgranti)",
                     "italic(Nimbochromis~linni)",
                     "italic(Nimbochromis~livingstoni)",
                     "italic(Nimbochromis~polystigma)",
                     "italic(Dimidiochromis~kiwinge)",
                     "italic(Dimidiochromis~strigatus)",
                     "italic(Dimidiochromis~dimidiatus)",
                     "italic(Tyrannochromis~nigriventer)",
                     "italic(Champsochromis~caeruelus)"),
           hjust = 0, parse = TRUE, size = 2.5) +
  xlab("") +
  ylab("") +
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank())

obj.diplo <- readRDS("data/diplotaxodon.rds")

ggdf <- data.frame(PC1 = obj.diplo$u[, 1],
                   PC2 = obj.diplo$u[, 2],
                   pop = obj.diplo$pop)

p2 <- ggplot(ggdf, aes(x = PC1, y = PC2, fill = pop)) +
  geom_point(size = 2.5, shape = 21, stroke = 1) +
  scale_fill_manual(labels = sort(unique(ggdf$pop)),
                    values = c("#D55E00", "#E69F00", "#56B4E9")) +
  guides(fill = guide_legend(nrow = 5)) +
  theme_bw() +
  theme(axis.text = element_text(face = "bold"),
        legend.text = element_text(face = "bold", size = 10),
        legend.key.height = unit(2, "line"),
        legend.key.width = unit(2, "line"),
        legend.justification = c(0, 1),
        legend.position = c(0, 1),
        legend.key = element_rect(fill = NA),
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.background = element_rect(fill=alpha('white', 0.0)))

plot_grid(p1, p2, labels = c("A", "B"))
```

```{r, fig.height=8}
pcadapt.x <- scan("data/diplotaxodon_pcadapt_x.txt")
pcadapt.stat <- scan("data/diplotaxodon_pcadapt.txt")
rndmin <- scan("data/diplotaxodon_rndmin.txt")
bdf <- scan("data/diplotaxodon_bdf.txt")
f <- scan("data/diplotaxodon_f.txt")
d <- scan("data/diplotaxodon_d.txt")

rndmin <- (median(rndmin) - rndmin) / mad(rndmin)
bdf <- (bdf - median(bdf)) / mad(bdf)
f <- (f - median(f)) / mad(f)
d <- (d - median(d)) / mad(d)

data.frame(x = c(rep(1:length(rndmin), 3), pcadapt.x, 1:length(rndmin)),
           y = c(bdf, d, f, pcadapt.stat, rndmin),
           Method = as.factor(c(rep("Bdf", length(bdf)),
                                rep("D", length(d)),
                                rep("f", length(f)),
                                rep("pcadapt", length(pcadapt.x)),
                                rep("RNDmin", length(rndmin))))) %>%
  mutate(Method = factor(Method, labels = c(expression(bold(Bd)[bolditalic(f)]),
                                            expression(bolditalic(D)),
                                            expression(bolditalic(f[bolditalic(d)])),
                                            expression(bold(pcadapt)),
                                            expression(bolditalic(RND)[bold(min)])))) %>%
  ggplot(aes(x = x, y = y, colour = Method)) +
  geom_line() +
  geom_hline(yintercept = 3, linetype = 2, size = 0.25) +
  facet_wrap(~Method, ncol = 1, scales = "free", labeller = label_parsed) +
  scale_color_manual(values = c("#D55E00", # Bdf
                                "#E69F00", # D
                                "#009E73", # f
                                "#56B4E9", # pcadapt
                                "#CC79A7")) + # RNDmin
  guides(colour = FALSE) +
  theme_bw(base_size = 20) +
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        strip.text.x = element_text(size = 10, margin = margin(.1, 0, .1, 0, "cm")))

```

